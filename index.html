<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>clojure.java.jdbc - JDBC-based SQL Interface 0.6.0 API documentation</title>
    <link rel="icon" href="static/favicon.png" />
    <link rel="shortcut icon" href="static/favicon.png" />
    <link rel="stylesheet" href="static/clojure.css" type="text/css" media="all" />
    <link rel="stylesheet" href="static/wiki.css" type="text/css" media="all" />
    <link rel="stylesheet" href="static/internal.css" type="text/css" media="all" />
    <style>.menuWrapper{height: 36px;}</style>
  </head>
<!--
This document was auto-generated from the source by the clojure autodoc system.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
-->
  <body>
    <div id="AllContentContainer">
      <div id="Header">
	<a href="index.html" id="Logo"><img src="static/clojure-icon.gif" width="100" height="100" alt="Clojure" /></a>
	<h1><a href="index.html" id="page-header" title="page header title">java.jdbc API Reference</a></h1>
      </div>
      <div id="leftcolumn"><div style="text-align: center;"></div>
<div class="menu">
  <div class="WikiCustomNav WikiElement wiki">
    <span class="toc-header"><span id="project-name">JDBC-based SQL Interface</span> <span id="version">0.6.0</span> API</span><br />
    <ul>
      <li><a href="index.html" class="wiki_link">Overview</a></li>
      <li><a href="api-index.html" class="wiki_link">API Index</a></li>
    </ul>
    
    
    <a class="wiki_link" href="http://clojure.org">Clojure Home</a>
  </div>
</div>
</div>
      <div id="rightcolumn">
	<div id="Content">
	  <div class="contentBox"><div class="innerContentBox">
              <div class="wiki wikiPage" id="content_view">
                <div id="right-sidebar"><div id="toc">
  <h1 class="nopad">Table of Contents</h1>
  <div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#toc0">Overview</a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#proto-section">Protocols</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/IResultSetReadColumn" class="toc-entry-anchor">IResultSetReadColumn</a>
      <div class="toc-subentry" style="margin-left: 1em;">
        <a href="#clojure.java.jdbc/result-set-read-column" class="toc-subentry-anchor">result-set-read-column</a>
      </div>
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/ISQLParameter" class="toc-entry-anchor">ISQLParameter</a>
      <div class="toc-subentry" style="margin-left: 1em;">
        <a href="#clojure.java.jdbc/set-parameter" class="toc-subentry-anchor">set-parameter</a>
      </div>
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/ISQLValue" class="toc-entry-anchor">ISQLValue</a>
      <div class="toc-subentry" style="margin-left: 1em;">
        <a href="#clojure.java.jdbc/sql-value" class="toc-subentry-anchor">sql-value</a>
      </div>
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#"></a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#var-section">Vars and Functions</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/as-sql-name" class="toc-entry-anchor">as-sql-name</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/create-table-ddl" class="toc-entry-anchor">create-table-ddl</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/db-connection" class="toc-entry-anchor">db-connection</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/db-do-commands" class="toc-entry-anchor">db-do-commands</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/db-do-prepared" class="toc-entry-anchor">db-do-prepared</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/db-do-prepared-return-keys" class="toc-entry-anchor">db-do-prepared-return-keys</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/db-find-connection" class="toc-entry-anchor">db-find-connection</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/db-is-rollback-only" class="toc-entry-anchor">db-is-rollback-only</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/db-query-with-resultset" class="toc-entry-anchor">db-query-with-resultset</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/db-set-rollback-only!" class="toc-entry-anchor">db-set-rollback-only!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/db-transaction*" class="toc-entry-anchor">db-transaction*</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/db-unset-rollback-only!" class="toc-entry-anchor">db-unset-rollback-only!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/delete!" class="toc-entry-anchor">delete!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/drop-table-ddl" class="toc-entry-anchor">drop-table-ddl</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/execute!" class="toc-entry-anchor">execute!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/find-by-keys" class="toc-entry-anchor">find-by-keys</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/get-by-id" class="toc-entry-anchor">get-by-id</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/get-connection" class="toc-entry-anchor">get-connection</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/insert!" class="toc-entry-anchor">insert!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/insert-multi!" class="toc-entry-anchor">insert-multi!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/metadata-query" class="toc-entry-anchor">metadata-query</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/metadata-result" class="toc-entry-anchor">metadata-result</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/prepare-statement" class="toc-entry-anchor">prepare-statement</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/print-sql-exception" class="toc-entry-anchor">print-sql-exception</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/print-sql-exception-chain" class="toc-entry-anchor">print-sql-exception-chain</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/print-update-counts" class="toc-entry-anchor">print-update-counts</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/query" class="toc-entry-anchor">query</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/quoted" class="toc-entry-anchor">quoted</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/result-set-seq" class="toc-entry-anchor">result-set-seq</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/update!" class="toc-entry-anchor">update!</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/with-db-connection" class="toc-entry-anchor">with-db-connection</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/with-db-metadata" class="toc-entry-anchor">with-db-metadata</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.java.jdbc/with-db-transaction" class="toc-entry-anchor">with-db-transaction</a>
      
    </div>
  </div>
</div>
</div>
                <div id="content-tag"><h1 id="overview">API for <span id="clojure.java.jdbc">clojure.java.jdbc</span>
  - <span id="header-project">JDBC-based SQL Interface</span> <span id="header-version">0.6.0</span><span id="header-status-block"> (<span id="header-status">in development</span>)</span>
  </h1>
<span id="author-line">by <span id="author-name">Stephen C. Gilardi, Sean Corfield</span><br /></span>
<br />Full namespace name: <span id="long-name">clojure.java.jdbc</span>
<p></p>
<h2>Overview</h2>
<div id="home-page">Project home page is <a href="http://github.com/clojure/java.jdbc/">http://github.com/clojure/java.jdbc/</a></div>
<pre id="namespace-docstr">A Clojure interface to SQL databases via JDBC

clojure.java.jdbc provides a simple abstraction for CRUD (create, read,
update, delete) operations on a SQL database, along with basic transaction
support. Basic DDL operations are also supported (create table, drop table,
access to table metadata).

Maps are used to represent records, making it easy to store and retrieve
data. Results can be processed using any standard sequence operations.

For most operations, Java's PreparedStatement is used so your SQL and
parameters can be represented as simple vectors where the first element
is the SQL string, with ? for each parameter, and the remaining elements
are the parameter values to be substituted. In general, operations return
the number of rows affected, except for a single record insert where any
generated keys are returned (as a map).

For more documentation, see:

<a href="http://clojure-doc.org/articles/ecosystem/java_jdbc/home.html">http://clojure-doc.org/articles/ecosystem/java_jdbc/home.html</a></pre>


<br />

<div id="proto-section">
  <p></p>
  <h2>Protocols</h2>
  <div id="proto-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/IResultSetReadColumn">IResultSetReadColumn</h2>
    <span id="proto-type">Protocol</span><br />
    <pre id="proto-docstr">Protocol for reading objects from the java.sql.ResultSet. Default
implementations (for Object and nil) return the argument, and the
Boolean implementation ensures a canonicalized true/false value,
but it can be extended to provide custom behavior for special types.</pre>
    Known implementations: <span id="proto-impls">java.lang.Boolean, nil, Object</span>
    <div id="proto-var-entry">
      <br />
      <h3 id="clojure.java.jdbc/result-set-read-column">result-set-read-column</h3>
      <span id="var-type">function</span><br />
      <pre id="var-usage">Usage: (result-set-read-column val rsmeta idx)
</pre>
      <pre id="var-docstr">Function for transforming values after reading them from the database</pre>
      
      
      
    </div>
    
    
    <a id="proto-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L363">Source</a>
  </div><div id="proto-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/ISQLParameter">ISQLParameter</h2>
    <span id="proto-type">Protocol</span><br />
    <pre id="proto-docstr">Protocol for setting SQL parameters in statement objects, which
can convert from Clojure values. The default implementation just
delegates the conversion to ISQLValue's sql-value conversion and
uses .setObject on the parameter. It can be extended to use other
methods of PreparedStatement to convert and set parameter values.</pre>
    Known implementations: <span id="proto-impls">nil, Object</span>
    <div id="proto-var-entry">
      <br />
      <h3 id="clojure.java.jdbc/set-parameter">set-parameter</h3>
      <span id="var-type">function</span><br />
      <pre id="var-usage">Usage: (set-parameter val stmt ix)
</pre>
      <pre id="var-docstr">Convert a Clojure value into a SQL value and store it as the ix'th
parameter in the given SQL statement object.</pre>
      
      
      
    </div>
    
    
    <a id="proto-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L344">Source</a>
  </div><div id="proto-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/ISQLValue">ISQLValue</h2>
    <span id="proto-type">Protocol</span><br />
    <pre id="proto-docstr">Protocol for creating SQL values from Clojure values. Default
implementations (for Object and nil) just return the argument,
but it can be extended to provide custom behavior to support
exotic types supported by different databases.</pre>
    Known implementations: <span id="proto-impls">nil, Object</span>
    <div id="proto-var-entry">
      <br />
      <h3 id="clojure.java.jdbc/sql-value">sql-value</h3>
      <span id="var-type">function</span><br />
      <pre id="var-usage">Usage: (sql-value val)
</pre>
      <pre id="var-docstr">Convert a Clojure value into a SQL value.</pre>
      
      
      
    </div>
    
    
    <a id="proto-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L330">Source</a>
  </div>
</div>

<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/as-sql-name">as-sql-name</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (as-sql-name f)
       (as-sql-name f x)
</pre>
    <pre id="var-docstr">Given a naming strategy function and a keyword or string, return
a string per that naming strategy.
A name of the form x.y is treated as multiple names, x, y, etc,
and each are turned into strings via the naming strategy and then
joined back together so x.y might become `x`.`y` if the naming
strategy quotes identifiers with `.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L51">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/create-table-ddl">create-table-ddl</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (create-table-ddl table specs)
       (create-table-ddl table specs opts)
</pre>
    <pre id="var-docstr">Given a table name and a vector of column specs return the DDL string for
creating that table. An options map may be provided that can contain:
:table-spec -- a string that is appended to the DDL -- and/or
:entities -- a function to specify how column names are transformed.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L1137">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/db-connection">db-connection</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (db-connection db)
</pre>
    <pre id="var-docstr">Returns the current database connection (or throws if there is none)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L553">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/db-do-commands">db-do-commands</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (db-do-commands db sql-commands)
       (db-do-commands db transaction? sql-commands)
</pre>
    <pre id="var-docstr">Executes SQL commands on the specified database connection. Wraps the commands
in a transaction if transaction? is true. transaction? can be ommitted and it
defaults to true. Accepts a single SQL command (string) or a vector of them.
Uses executeBatch. This may affect what SQL you can run via db-do-commands.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L704">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/db-do-prepared">db-do-prepared</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (db-do-prepared db sql-params)
       (db-do-prepared db transaction? sql-params)
       (db-do-prepared db transaction? sql-params opts)
</pre>
    <pre id="var-docstr">Executes an (optionally parameterized) SQL prepared statement on the
open database connection. Each param-group is a seq of values for all of
the parameters. transaction? can be omitted and defaults to true.
The sql parameter can either be a SQL string or a PreparedStatement.
Return a seq of update counts (one count for each param-group).</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L794">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/db-do-prepared-return-keys">db-do-prepared-return-keys</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (db-do-prepared-return-keys db sql-params)
       (db-do-prepared-return-keys db transaction? sql-params)
       (db-do-prepared-return-keys db transaction? sql-params opts)
</pre>
    <pre id="var-docstr">Executes an (optionally parameterized) SQL prepared statement on the
open database connection. The param-group is a seq of values for all of
the parameters. transaction? can be ommitted and will default to true.
Return the generated keys for the (single) update/insert.
A PreparedStatement may be passed in, instead of a SQL string, in which
case :return-keys MUST BE SET on that PreparedStatement!</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L754">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/db-find-connection">db-find-connection</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (db-find-connection db)
</pre>
    <pre id="var-docstr">Returns the current database connection (or nil if there is none)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L547">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/db-is-rollback-only">db-is-rollback-only</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (db-is-rollback-only db)
</pre>
    <pre id="var-docstr">Returns true if the outermost transaction will rollback rather than
commit when complete</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L570">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/db-query-with-resultset">db-query-with-resultset</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (db-query-with-resultset db sql-params func)
       (db-query-with-resultset db sql-params func opts)
</pre>
    <pre id="var-docstr">Executes a query, then evaluates func passing in the raw ResultSet as an
 argument. The second argument is a vector containing either:
  [sql &amp; params] - a SQL query, followed by any parameters it needs
  [stmt &amp; params] - a PreparedStatement, followed by any parameters it needs
                    (the PreparedStatement already contains the SQL query)
The opts map is passed to prepare-statement.
Uses executeQuery. This may affect what SQL you can run via query.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L817">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/db-set-rollback-only!">db-set-rollback-only!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (db-set-rollback-only! db)
</pre>
    <pre id="var-docstr">Marks the outermost transaction such that it will rollback rather than
commit when complete</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L559">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/db-transaction*">db-transaction*</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (db-transaction* db func)
       (db-transaction* db func {:keys [isolation read-only?], :as opts})
</pre>
    <pre id="var-docstr">Evaluates func as a transaction on the open database connection. Any
nested transactions are absorbed into the outermost transaction. By
default, all database updates are committed together as a group after
evaluating the outermost body, or rolled back on any uncaught
exception. If rollback is set within scope of the outermost transaction,
the entire transaction will be rolled back rather than committed when
complete.
The isolation option may be :none, :read-committed, :read-uncommitted,
:repeatable-read, or :serializable. Note that not all databases support
all of those isolation levels, and may either throw an exception or
substitute another isolation level.
The read-only? option puts the transaction in readonly mode (if supported).</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L584">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/db-unset-rollback-only!">db-unset-rollback-only!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (db-unset-rollback-only! db)
</pre>
    <pre id="var-docstr">Marks the outermost transaction such that it will not rollback when complete</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L565">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/delete!">delete!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (delete! db table where-clause)
       (delete! db table where-clause {:keys [entities transaction?], :or {entities identity, transaction? true}})
</pre>
    <pre id="var-docstr">Given a database connection, a table name and a where clause of columns to match,
perform a delete. The options may specify how to transform column names in the
map (default 'as-is') and whether to run the delete in a transaction (default true).
Example:
  (delete! db :person ["zip = ?" 94546])
is equivalent to:
  (execute! db ["DELETE FROM person WHERE zip = ?" 94546])</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L975">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/drop-table-ddl">drop-table-ddl</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (drop-table-ddl name)
       (drop-table-ddl name {:keys [entities], :or {entities identity}})
</pre>
    <pre id="var-docstr">Given a table name, return the DDL string for dropping that table.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L1155">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/execute!">execute!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (execute! db sql-params)
       (execute! db sql-params {:keys [transaction? multi?], :or {transaction? true, multi? false}})
</pre>
    <pre id="var-docstr">Given a database connection and a vector containing SQL (or PreparedStatement)
followed by optional parameters, perform a general (non-select) SQL operation.
The :transaction? option specifies whether to run the operation in a
transaction or not (default true).
If the :multi? option is false (the default), the SQL statement should be
followed by the parameters for that statement.
If the :multi? option is true, the SQL statement should be followed by one or
more vectors of parameters, one for each application of the SQL statement.
If there are no parameters specified, executeUpdate will be used, otherwise
executeBatch will be used. This may affect what SQL you can run via execute!</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L942">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/find-by-keys">find-by-keys</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (find-by-keys db table columns)
       (find-by-keys db table columns opts)
</pre>
    <pre id="var-docstr">Given a database connection, a table name, a map of column name/value
pairs, and an optional options map, return any matching rows.
An :order-by option may be supplied to sort the rows by a sequence of
columns, e.g,. {:order-by [:name {:age :desc]}</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L907">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/get-by-id">get-by-id</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (get-by-id db table pk-value)
       (get-by-id db table pk-value pk-name-or-opts)
       (get-by-id db table pk-value pk-name opts)
</pre>
    <pre id="var-docstr">Given a database connection, a table name, a primary key value, an
optional primary key column name, and an optional options map, return
a single matching row, or nil.
The primary key column name defaults to :id.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L927">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/get-connection">get-connection</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (get-connection {:keys [connection factory connection-uri classname subprotocol subname dbtype dbname host port datasource username password user name environment], :as db-spec})
</pre>
    <pre id="var-docstr">Creates a connection to a database. db-spec is usually a map containing connection
parameters but can also be a URI or a String. The various possibilities are described
below:

Existing Connection:
  :connection  (required) an existing open connection that can be used
               but cannot be closed (only the parent connection can be closed)

Factory:
  :factory     (required) a function of one argument, a map of params
  (others)     (optional) passed to the factory function in a map

DriverManager:
  :subprotocol (required) a String, the jdbc subprotocol
  :subname     (required) a String, the jdbc subname
  :classname   (optional) a String, the jdbc driver class name
  (others)     (optional) passed to the driver as properties.

DriverManager (alternative):
  :dbtype      (required) a String, the type of the database (the jdbc subprotocol)
  :dbname      (required) a String, the name of the database
  :host        (optional) a String, the host name/IP of the database
                          (defaults to 127.0.0.1)
  :port        (optional) a Long, the port of the database
                          (defaults to 3306 for mysql, 1433 for mssql/jtds, else nil)
  (others)     (optional) passed to the driver as properties.

DataSource:
  :datasource  (required) a javax.sql.DataSource
  :username    (optional) a String
  :user        (optional) a String - an alternate alias for :username
                          (added after 0.3.0-beta2 for consistency JDBC-74)
  :password    (optional) a String, required if :username is supplied

JNDI:
  :name        (required) a String or javax.naming.Name
  :environment (optional) a java.util.Map

Raw:
  :connection-uri (required) a String
               Passed directly to DriverManager/getConnection

URI:
  Parsed JDBC connection string - see below

String:
  subprotocol://user:password@host:post/subname
               An optional prefix of jdbc: is allowed.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L192">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/insert!">insert!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (insert! db table row)
       (insert! db table cols-or-row values-or-opts)
       (insert! db table cols values opts)
</pre>
    <pre id="var-docstr">Given a database connection, a table name and either a map representing a rows,
or a list of column names followed by a list of column values also representing
a single row, perform an insert.
The row map or column value vector may be followed by a map of options:
The :transaction? option specifies whether to run in a transaction or not.
The default is true (use a transaction). The :entities option specifies how
to convert the table name and column names to SQL entities.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L1071">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/insert-multi!">insert-multi!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (insert-multi! db table rows)
       (insert-multi! db table cols-or-rows values-or-opts)
       (insert-multi! db table cols values opts)
</pre>
    <pre id="var-docstr">Given a database connection, a table name and either a sequence of maps (for
rows) or a sequence of column names, followed by a sequence of vectors (for
the values in each row), and possibly a map of options, insert that data into
the database.
The :transaction? option specifies whether to run in a transaction or not.
The default is true (use a transaction). The :entities option specifies how
to convert the table name and column names to SQL entities.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L1087">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/metadata-query">metadata-query</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (metadata-query meta-query &amp; opt-args)
</pre>
    <pre id="var-docstr">Given a Java expression that extracts metadata (in the context of with-db-metadata),
and a map of options like metadata-result, manage the connection for a single
metadata-based query. Example usage:

(with-db-metadata [meta db-spec]
  (metadata-query (.getTables meta nil nil nil (into-array String ["TABLE"]))
    {:row-fn ... :result-set-fn ...}))</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L692">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/metadata-result">metadata-result</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (metadata-result rs-or-value)
       (metadata-result rs-or-value {:keys [identifiers as-arrays? row-fn result-set-fn], :or {identifiers lower-case, row-fn identity}})
</pre>
    <pre id="var-docstr">If the argument is a java.sql.ResultSet, turn it into a result-set-seq,
else return it as-is. This makes working with metadata easier.
Also accepts an option map containing :identifiers, :as-arrays?, :row-fn,
and :result-set-fn to control how the ResultSet is transformed and returned.
See query for more details.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L673">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/prepare-statement">prepare-statement</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (prepare-statement con sql)
       (prepare-statement con sql {:keys [return-keys result-type concurrency cursors fetch-size max-rows timeout]})
</pre>
    <pre id="var-docstr">Create a prepared statement from a connection, a SQL string and a map
of options:
   :return-keys truthy | nil - default nil
     for some drivers, this may be a vector of column names to identify
     the generated keys to return, otherwise it should just be true
   :result-type :forward-only | :scroll-insensitive | :scroll-sensitive
   :concurrency :read-only | :updatable
   :cursors
   :fetch-size n
   :max-rows n
   :timeout n</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L453">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/print-sql-exception">print-sql-exception</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (print-sql-exception exception)
</pre>
    <pre id="var-docstr">Prints the contents of an SQLException to *out*</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L507">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/print-sql-exception-chain">print-sql-exception-chain</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (print-sql-exception-chain exception)
</pre>
    <pre id="var-docstr">Prints a chain of SQLExceptions to *out*</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L521">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/print-update-counts">print-update-counts</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (print-update-counts exception)
</pre>
    <pre id="var-docstr">Prints the update counts from a BatchUpdateException to *out*</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L533">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/query">query</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (query db sql-params)
       (query db sql-params {:keys [result-set-fn row-fn identifiers as-arrays?], :or {row-fn identity, identifiers lower-case}, :as opts})
</pre>
    <pre id="var-docstr">Given a database connection and a vector containing SQL and optional parameters,
perform a simple database query. The options specify how to construct the result
set (and are also passed to prepare-statement as needed):
  :result-set-fn - applied to the entire result set, default doall / vec
      if :as-arrays? true, :result-set-fn will default to vec
      if :as-arrays? false, :result-set-fn will default to doall
  :row-fn - applied to each row as the result set is constructed, default identity
  :identifiers - applied to each column name in the result set, default lower-case
  :as-arrays? - return the results as a set of arrays, default false.
The second argument is a vector containing a SQL string or PreparedStatement, followed
by any parameters it needs.
See also prepare-statement for additional options.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L853">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/quoted">quoted</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (quoted q)
       (quoted q x)
</pre>
    <pre id="var-docstr">With a single argument, returns a naming strategy function that quotes
names. The single argument can either be a single character or a vector
pair of characters.
Can also be called with two arguments - a quoting argument and a name -
and returns the fully quoted string:
  (quoted \` "foo") will return "`foo`"
  (quoted [\[ \]] "foo") will return "[foo]"</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L68">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/result-set-seq">result-set-seq</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (result-set-seq rs)
       (result-set-seq rs {:keys [identifiers as-arrays?], :or {identifiers lower-case}})
</pre>
    <pre id="var-docstr">Creates and returns a lazy sequence of maps corresponding to the rows in the
java.sql.ResultSet rs. Loosely based on clojure.core/resultset-seq but it
respects the specified naming strategy. Duplicate column names are made unique
by appending _N before applying the naming strategy (where N is a unique integer),
unless the :as-arrays? option is :cols-as-is, in which case the column names
are untouched (the result set maintains column name/value order).
The :identifiers option specifies how SQL column names are converted to Clojure
keywords. The default is to convert them to lower case.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L381">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/update!">update!</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (update! db table set-map where-clause)
       (update! db table set-map where-clause {:keys [entities transaction?], :or {entities identity, transaction? true}})
</pre>
    <pre id="var-docstr">Given a database connection, a table name, a map of column values to set and a
where clause of columns to match, perform an update. The options may specify
how column names (in the set / match maps) should be transformed (default
'as-is') and whether to run the update in a transaction (default true).
Example:
  (update! db :person {:zip 94540} ["zip = ?" 94546])
is equivalent to:
  (execute! db ["UPDATE person SET zip = ? WHERE zip = ?" 94540 94546])</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L1121">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/with-db-connection">with-db-connection</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (with-db-connection binding &amp; body)
</pre>
    <pre id="var-docstr">Evaluates body in the context of an active connection to the database.
(with-db-connection [con-db db-spec]
  ... con-db ...)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L652">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/with-db-metadata">with-db-metadata</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (with-db-metadata binding &amp; body)
</pre>
    <pre id="var-docstr">Evaluates body in the context of an active connection with metadata bound
to the specified name. See also metadata-result for dealing with the results
of operations that retrieve information from the metadata.
(with-db-metadata [md db-spec]
  ... md ...)</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L662">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.java.jdbc/with-db-transaction">with-db-transaction</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (with-db-transaction binding &amp; body)
</pre>
    <pre id="var-docstr">Evaluates body in the context of a transaction on the specified database connection.
The binding provides the database connection for the transaction and the name to which
that is bound for evaluation of the body. The binding may also specify the isolation
level for the transaction, via the :isolation option and/or set the transaction to
readonly via the :read-only? option.
(with-db-transaction [t-con db-spec {:isolation level :read-only? true}]
  ... t-con ...)
See db-transaction* for more details.</pre>
    
    
    <a id="var-source" href="https://github.com/clojure/java.jdbc/blob/190a8c7257c4de6e9859d7e5d0240d919c3788c2/src/main/clojure/clojure/java/jdbc.clj#L638">Source</a>
  </div>
</div>


</div>
              </div>
            </div>
          </div>
	</div>
	<div id="foot">
	  <div id="copyright" style="text-align: center;">Copyright 2007-2016 by Rich Hickey and the various contributors</div>
	</div>
      </div>
      <div id="DesignedBy">Logo &amp; site design by <a href="http://www.tomhickey.com" title="Visit Tom Hickey's website.">Tom Hickey</a>.<br />
      Clojure auto-documentation system by Tom Faulhaber.</div>
    </div>
    <!-- /AllContentContainer -->
  </body>

</html>